import os
import sys
import pickle
import joblib
import pefile
import math

def calculate_entropy(data):
    """Calculate the entropy of a given data."""
    if not data:
        return 0
    
    entropy = 0
    for byte in set(data):
        p_x = float(data.count(byte)) / len(data)
        entropy -= p_x * math.log2(p_x)
    return entropy

def classify_file(file_path):
    # Load the classifier and feature list
    clf = joblib.load('C:/Users/orrin/Documents/classifier/classifier.pk1')
    with open('C:/Users/orrin/Documents/classifier/features.pkl', 'rb') as f:
        features = pickle.load(f)

    # Extract features from the file
    data = extract_infos(file_path)

    # Prepare features for prediction
    pe_features = [data[x] for x in features]

    # Predict
    result = clf.predict([pe_features])[0]

    # Print the result
    print('The file %s is %s' % (os.path.basename(file_path), ['safe', 'malware'][result]))

def extract_infos(fpath):
    res = {}
    pe = pefile.PE(fpath)
    res['Machine'] = pe.FILE_HEADER.Machine
    res['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
    res['Characteristics'] = pe.FILE_HEADER.Characteristics
    res['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
    res['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
    res['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
    res['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
    res['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
    res['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    res['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
    res['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
    res['MajorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
    res['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
    res['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
    res['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics
    sections = [section.get_entropy() for section in pe.sections]
    res['SectionsMinEntropy'] = min(sections) if sections else 0  # Calculate min entropy of sections
    res['SectionsMaxEntropy'] = max(sections) if sections else 0  # Calculate max entropy of sections
    
    
    return res
if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("Usage: python CheckMalware.py <file_path>")
        sys.exit(1)
    
    file_path = sys.argv[1]
    classify_file(file_path)
