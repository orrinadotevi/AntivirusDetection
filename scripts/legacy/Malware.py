import numpy as np
import pickle
import joblib
import pefile #Portable Executable files, just analyzes .exe, .dll, .sys files and many more

# Load model and features
def load_model_and_features(model_path, features_path):
    model = joblib.load(model_path)
    with open(features_path, 'rb') as f:
        features = pickle.load(f)
    return model, features

def extract_file_features(file_path, features):
    try:
        pe = pefile.PE(file_path)
        extracted_features = []
        extracted_features.append(pe.OPTIONAL_HEADER.DllCharacteristics)
        extracted_features.append(pe.FILE_HEADER.Machine)
        if hasattr(pe.FILE_HEADER, 'Characteristics'):
            extracted_features.append(pe.FILE_HEADER.Characteristics)
        else:
            extracted_features.append(0)  # Placeholder value if the attribute is missing
        # Extract Version Information Size
        version_info_size = 0
        for entry in pe.FileInfo:
            if hasattr(entry, 'StringTable'):
                for st_entry in entry.StringTable:
                    version_info_size += len(st_entry.entries)
        extracted_features.append(version_info_size)
        # Extract Sections Max Entropy
        sections_entropy = [s.get_entropy() for s in pe.sections]
        extracted_features.append(max(sections_entropy))
        extracted_features.append(pe.OPTIONAL_HEADER.ImageBase)
        if hasattr(pe.OPTIONAL_HEADER, 'MajorSubsystemVersion'):
            extracted_features.append(pe.OPTIONAL_HEADER.MajorSubsystemVersion)
        else:
            extracted_features.append(0)  # Placeholder value if the attribute is missing
        extracted_features.append(pe.OPTIONAL_HEADER.Subsystem)
        # Estimate SizeOfOptionalHeader
        size_of_optional_header = pe.sections[0].VirtualAddress - pe.OPTIONAL_HEADER.get_file_offset()
        extracted_features.append(size_of_optional_header)
        if hasattr(pe.OPTIONAL_HEADER, 'MajorOperatingSystemVersion'):
            extracted_features.append(pe.OPTIONAL_HEADER.MajorOperatingSystemVersion)
        else:
            extracted_features.append(0)  # Placeholder value if the attribute is missing
        # Extract Resources Max Entropy
        try:
            resources_entropy = [entry.entropy for entry in pe.resources.directory.entries]
            extracted_features.append(max(resources_entropy))
        except AttributeError:
            extracted_features.append(0)  # Placeholder value if the attribute is missing
        # Extract Resources Min Entropy
        try:
            resources_entropy = [entry.entropy for entry in pe.resources.directory.entries]
            extracted_features.append(min(resources_entropy))
        except AttributeError:
            extracted_features.append(0)  # Placeholder value if the attribute is missing
        # Ensure that the order of features matches the feature order used during training
        return np.array(extracted_features)
    except Exception as e:
        print("Error occurred while extracting features from the file:", e)
        return None




# Predict file status
def predict_file_status(model, file_features):
    prediction = model.predict(file_features.reshape(1, -1))
    return prediction[0]

# Define thresholds (optional)
# Adjust these thresholds based on the characteristics of your model and application requirements
MALWARE_THRESHOLD = 0.5

# Main function to check file status
def check_file_status(model_path, features_path, file_path):
    model, features = load_model_and_features(model_path, features_path)
    file_features = extract_file_features(file_path, features)
    if file_features is None:
        print("Error: Failed to extract features from the file.")
        return
    status = predict_file_status(model, file_features)
    if status == 1:
        print("The file is classified as MALWARE.")
    else:
        print("The file is classified as CLEAR of malware.")

# Example usage
if __name__ == "__main__":
    model_path = 'C:/Users/orrin/Documents/classifier/classifier.pk1'
    features_path = 'C:/Users/orrin/Documents/classifier/features.pkl'
    file_path = 'C:/Users/orrin/Documents/JLECmd/JLECmd.exe'
    check_file_status(model_path, features_path, file_path)
